
---

## `future_improvements.txt`

```text
FUTURE IMPROVEMENTS / NEXT STEPS
================================

1. Better intent classification
   - Right now we use rule-based checks (starts with "what", has "average", "by", etc.)
   - Replace with a small classifier that looks at length, presence of schema terms, and "time window" words.
   - Goal: never send analytic questions to the definition branch.

2. Smarter date-window rewriting
   - LLM often produces "WHERE order_purchase_timestamp = (SELECT max(...))" which kills the result.
   - We already strip some of these, but we can:
     - detect historic datasets (like Olist 2016–2018),
     - rewrite "last 90 days" → "max_ts - interval 90 day" over that historic max.

3. Model discovery / health check
   - At startup, call Gemini "list models" and/or OpenRouter "models" to verify the configured model exists.
   - If it doesn't, auto-pick a known-fast model.
   - Expose this on `/debug-env`.

4. Caching layer
   - Many users will ask the same NL question ("orders per month", "top categories") repeatedly.
   - Cache NL → SQL and SQL → result for a short TTL to avoid repeated LLM calls.

5. RAG for definitions
   - Instead of asking the LLM, index an internal Olist data dictionary.
   - If term not in local glossary, search the RAG index first, only then call LLM.
   - This makes "what is invoice" and "what is freight_value" more deterministic.

6. SQL validation / linting
   - After LLM generates SQL, run a quick DuckDB "EXPLAIN" or "DESCRIBE" to detect missing tables/columns.
   - If it's clearly broken, auto-send a correction prompt without returning an error to the UI.

7. UI improvements
   - If query has a time dimension → auto-plot.
   - If query returns >= 2 numeric columns → offer "download CSV".
   - Add "show SQL" toggle instead of always showing code.

8. Auth / multi-tenant
   - Right now it’s single-user, no auth.
   - Add a simple API key or JWT in FastAPI to control access.
   - Store user-level history separately so LLM can see previous context per user.

9. Packaging
   - Split backend into modules: intents/, llm/, sql_fixes/, handlers/.
   - Add unit tests for:
     - translation fallback
     - intent detection
     - SQL post-processing

10. Deployment
    - Add production Dockerfile (multi-stage, gunicorn/uvicorn worker).
    - Add GitHub Actions to run tests + build image on push.
